<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>blancas.eisen.parser documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Eisen 0.1.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="blancas.eisen.clojure.html"><span>blancas.eisen.clojure</span></a></li><li><a href="blancas.eisen.core.html"><span>blancas.eisen.core</span></a></li><li class="current"><a href="blancas.eisen.parser.html"><span>blancas.eisen.parser</span></a></li><li><a href="blancas.eisen.trans.html"><span>blancas.eisen.trans</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="blancas.eisen.parser.html#var-add-decl"><span>add-decl</span></a></li><li><a href="blancas.eisen.parser.html#var-add-expr"><span>add-expr</span></a></li><li><a href="blancas.eisen.parser.html#var-add-op"><span>add-op</span></a></li><li><a href="blancas.eisen.parser.html#var-add-reserved"><span>add-reserved</span></a></li><li><a href="blancas.eisen.parser.html#var-and-op"><span>and-op</span></a></li><li><a href="blancas.eisen.parser.html#var-argument"><span>argument</span></a></li><li><a href="blancas.eisen.parser.html#var-ast-hook"><span>ast-hook</span></a></li><li><a href="blancas.eisen.parser.html#var-band-op"><span>band-op</span></a></li><li><a href="blancas.eisen.parser.html#var-bindings"><span>bindings</span></a></li><li><a href="blancas.eisen.parser.html#var-bor-op"><span>bor-op</span></a></li><li><a href="blancas.eisen.parser.html#var-bxor-op"><span>bxor-op</span></a></li><li><a href="blancas.eisen.parser.html#var-condex"><span>condex</span></a></li><li><a href="blancas.eisen.parser.html#var-cons-op"><span>cons-op</span></a></li><li><a href="blancas.eisen.parser.html#var-dec-lit*"><span>dec-lit*</span></a></li><li><a href="blancas.eisen.parser.html#var-doex"><span>doex</span></a></li><li><a href="blancas.eisen.parser.html#var-dot-op"><span>dot-op</span></a></li><li><a href="blancas.eisen.parser.html#var-eisen-code"><span>eisen-code</span></a></li><li><a href="blancas.eisen.parser.html#var-eisen-name"><span>eisen-name</span></a></li><li><a href="blancas.eisen.parser.html#var-eisen-style"><span>eisen-style</span></a></li><li><a href="blancas.eisen.parser.html#var-end-sequence"><span>end-sequence</span></a></li><li><a href="blancas.eisen.parser.html#var-equ-op"><span>equ-op</span></a></li><li><a href="blancas.eisen.parser.html#var-expr"><span>expr</span></a></li><li><a href="blancas.eisen.parser.html#var-factor"><span>factor</span></a></li><li><a href="blancas.eisen.parser.html#var-flt-lit*"><span>flt-lit*</span></a></li><li><a href="blancas.eisen.parser.html#var-fun-decl"><span>fun-decl</span></a></li><li><a href="blancas.eisen.parser.html#var-fun-lit"><span>fun-lit</span></a></li><li><a href="blancas.eisen.parser.html#var-fwd-decl"><span>fwd-decl</span></a></li><li><a href="blancas.eisen.parser.html#var-hex-lit*"><span>hex-lit*</span></a></li><li><a href="blancas.eisen.parser.html#var-id-arg"><span>id-arg</span></a></li><li><a href="blancas.eisen.parser.html#var-id-formal"><span>id-formal</span></a></li><li><a href="blancas.eisen.parser.html#var-identifier"><span>identifier</span></a></li><li><a href="blancas.eisen.parser.html#var-imp-decl"><span>imp-decl</span></a></li><li><a href="blancas.eisen.parser.html#var-in-sequence"><span>in-sequence</span></a></li><li><a href="blancas.eisen.parser.html#var-key-name"><span>key-name</span></a></li><li><a href="blancas.eisen.parser.html#var-lcat-op"><span>lcat-op</span></a></li><li><a href="blancas.eisen.parser.html#var-letex"><span>letex</span></a></li><li><a href="blancas.eisen.parser.html#var-letrec"><span>letrec</span></a></li><li><a href="blancas.eisen.parser.html#var-lexer"><span>lexer</span></a></li><li><a href="blancas.eisen.parser.html#var-lisp-id"><span>lisp-id</span></a></li><li><a href="blancas.eisen.parser.html#var-lisp-name"><span>lisp-name</span></a></li><li><a href="blancas.eisen.parser.html#var-list-lit"><span>list-lit</span></a></li><li><a href="blancas.eisen.parser.html#var-list-range"><span>list-range</span></a></li><li><a href="blancas.eisen.parser.html#var-local-binding"><span>local-binding</span></a></li><li><a href="blancas.eisen.parser.html#var-macro%3F"><span>macro?</span></a></li><li><a href="blancas.eisen.parser.html#var-map-lit"><span>map-lit</span></a></li><li><a href="blancas.eisen.parser.html#var-mod-decl"><span>mod-decl</span></a></li><li><a href="blancas.eisen.parser.html#var-mul-op"><span>mul-op</span></a></li><li><a href="blancas.eisen.parser.html#var-oct-lit*"><span>oct-lit*</span></a></li><li><a href="blancas.eisen.parser.html#var-or-op"><span>or-op</span></a></li><li><a href="blancas.eisen.parser.html#var-pattern"><span>pattern</span></a></li><li><a href="blancas.eisen.parser.html#var-pow-op"><span>pow-op</span></a></li><li><a href="blancas.eisen.parser.html#var-qualifier"><span>qualifier</span></a></li><li><a href="blancas.eisen.parser.html#var-re-lit"><span>re-lit</span></a></li><li><a href="blancas.eisen.parser.html#var-rel-op"><span>rel-op</span></a></li><li><a href="blancas.eisen.parser.html#var-seqex"><span>seqex</span></a></li><li><a href="blancas.eisen.parser.html#var-set-lit"><span>set-lit</span></a></li><li><a href="blancas.eisen.parser.html#var-setqex"><span>setqex</span></a></li><li><a href="blancas.eisen.parser.html#var-setvex"><span>setvex</span></a></li><li><a href="blancas.eisen.parser.html#var-shft-op"><span>shft-op</span></a></li><li><a href="blancas.eisen.parser.html#var-sym-arg"><span>sym-arg</span></a></li><li><a href="blancas.eisen.parser.html#var-uni-op"><span>uni-op</span></a></li><li><a href="blancas.eisen.parser.html#var-val-call"><span>val-call</span></a></li><li><a href="blancas.eisen.parser.html#var-val-decl"><span>val-decl</span></a></li><li><a href="blancas.eisen.parser.html#var-vec-range"><span>vec-range</span></a></li><li><a href="blancas.eisen.parser.html#var-vector-lit"><span>vector-lit</span></a></li><li><a href="blancas.eisen.parser.html#var-vector-pattern"><span>vector-pattern</span></a></li><li><a href="blancas.eisen.parser.html#var-wildcard"><span>wildcard</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>blancas.eisen.parser documentation</h2><pre class="doc">The Eisen Parser.

The Eisen Lexer is configured with the following settings:

comment-start        (*
comment-end          *)
comment-line         --
nested-comments      Yes
identifier-start     Lowercase or _
identifier-letter    Alphanumeric or _ ' ? ! . /
reserved-names       module import declare val fun fn _ if
		     then else let letrec in do end setq setv
case-sensitive       Yes
line-continuation    Backslash
trim-newline         Yes

Literal values follow the rules of Java and Clojure.</pre><div class="public" id="var-add-decl"><h3>add-decl</h3><div class="usage"><code>(add-decl decl)</code></div><pre class="doc">Adds an Eisen declaration.
</pre></div><div class="public" id="var-add-expr"><h3>add-expr</h3><div class="usage"><code>(add-expr expr)</code></div><pre class="doc">Adds an Eisen expression.
</pre></div><div class="public" id="var-add-op"><h3>add-op</h3><div class="usage"></div><pre class="doc">Additive operators plus and minus.
</pre></div><div class="public" id="var-add-reserved"><h3>add-reserved</h3><div class="usage"><code>(add-reserved coll)</code></div><pre class="doc">Adds the Eisen reserved word in the supplied collection.
</pre></div><div class="public" id="var-and-op"><h3>and-op</h3><div class="usage"></div><pre class="doc">Operator &amp;&amp; denotes logical and.
</pre></div><div class="public" id="var-argument"><h3>argument</h3><div class="usage"></div><pre class="doc">An argument to a function call; this does not include a function call
directly, but only through an expression in parenthesis.

Either one of:
* Keyword
* Character
* String
* Decimal number
* Octal number
* Hex number
* Floating-point number
* Boolean
* Nil
* List
* Vector
* Set
* Map
* Regular expression
* Value reference
* A sequenced expression in parenthesis</pre></div><div class="public" id="var-ast-hook"><h3>ast-hook</h3><div class="usage"></div><pre class="doc">A transformation of the AST.
</pre></div><div class="public" id="var-band-op"><h3>band-op</h3><div class="usage"></div><pre class="doc">Operator &amp; denotes bitwise and.
</pre></div><div class="public" id="var-bindings"><h3>bindings</h3><div class="usage"></div><pre class="doc">Parses zero or more val and fun declarations
as the equivalent of Clojure bindings.

local-binding ( ';' local-binding )* ( ';' )*</pre></div><div class="public" id="var-bor-op"><h3>bor-op</h3><div class="usage"></div><pre class="doc">Opertor | denotes bitwise or.
</pre></div><div class="public" id="var-bxor-op"><h3>bxor-op</h3><div class="usage"></div><pre class="doc">Opertor ^ denotes bitwise xor.
</pre></div><div class="public" id="var-condex"><h3>condex</h3><div class="usage"></div><pre class="doc">Parses a conditional expression.

'if' expression
'then' expression ( 'else' expression )?</pre></div><div class="public" id="var-cons-op"><h3>cons-op</h3><div class="usage"></div><pre class="doc">List construction operator.
</pre></div><div class="public" id="var-dec-lit*"><h3>dec-lit*</h3><div class="usage"></div><pre class="doc">Parses a decimal literal, with no leading sign.
</pre></div><div class="public" id="var-doex"><h3>doex</h3><div class="usage"></div><pre class="doc">Parses sequenced expressions; like seqex but using 'do'
and 'end'. Returns the value of the last expression.

'do' expression ( ';' expression )* ( ';' )* 'end'</pre></div><div class="public" id="var-dot-op"><h3>dot-op</h3><div class="usage"></div><pre class="doc">Parses a function name as a binary operator: .op.
</pre></div><div class="public" id="var-eisen-code"><h3>eisen-code</h3><div class="usage"></div><pre class="doc">Parses one or more declarations, or a single expressions.
</pre></div><div class="public" id="var-eisen-name"><h3>eisen-name</h3><div class="usage"></div><pre class="doc">An Eisen name is an identifier or a lisp name.
</pre></div><div class="public" id="var-eisen-style"><h3>eisen-style</h3><div class="usage"></div><pre class="doc">Lexical settings for the Eisen language.

comment-start        (*
comment-end          *)
comment-line         --
nested-comments      Yes
identifier-start     Lowercase or _
identifier-letter    Alphanumeric or _ ' ? ! . /
reserved-names       module import declare val fun fn _
		        if then else let letrec in do end
case-sensitive       Yes
line-continuation    Backslash
trim-newline         Yes</pre></div><div class="public" id="var-end-sequence"><h3>end-sequence</h3><div class="usage"></div><pre class="doc">Parses expressions separated by semicolons ending with 'end'.
Returns a vector of declarations, not a token map.

expression ( ';' expression )* ( ';' )* 'end'</pre></div><div class="public" id="var-equ-op"><h3>equ-op</h3><div class="usage"></div><pre class="doc">Equality operators; == denotes (=); != denotes not=.
</pre></div><div class="public" id="var-expr"><h3>expr</h3><div class="usage"></div><pre class="doc">Parses an Eisen expression.

Either one of:
* Sequenced expression, 'do' .. 'end'
* Conditional expression, 'if'
* Binding expression, 'let', 'letrec'
* Function literal, 'fn'
* Setting host data, 'setq', 'setv'</pre></div><div class="public" id="var-factor"><h3>factor</h3><div class="usage"></div><pre class="doc">A factor is an operand within an expression.

Either one of:
* Keyword
* Character
* String
* Decimal number
* Octal number
* Hex number
* Floating-point number
* Boolean
* Nil
* List
* Vector
* Set
* Map
* Regular expression
* Value reference
* Function call
* An expression in parenthesis</pre></div><div class="public" id="var-flt-lit*"><h3>flt-lit*</h3><div class="usage"></div><pre class="doc">Parses a floating-point literal, with no leading sign.
</pre></div><div class="public" id="var-fun-decl"><h3>fun-decl</h3><div class="usage"></div><pre class="doc">Parses a function definition.

'fun' identifier parameter* '=' expression</pre></div><div class="public" id="var-fun-lit"><h3>fun-lit</h3><div class="usage"></div><pre class="doc">Parses a function literal definition.

'fn' parameter* '=&gt;' expression</pre></div><div class="public" id="var-fwd-decl"><h3>fwd-decl</h3><div class="usage"></div><pre class="doc">Parses a forward declaration.

'declare' name+</pre></div><div class="public" id="var-hex-lit*"><h3>hex-lit*</h3><div class="usage"></div><pre class="doc">Parses a hex literal, with no leading sign.
</pre></div><div class="public" id="var-id-arg"><h3>id-arg</h3><div class="usage"></div><pre class="doc">Parses an identifier as an argument. It will be translated as
a Clojure symbol, and is expected to have been declared.</pre></div><div class="public" id="var-id-formal"><h3>id-formal</h3><div class="usage"></div><pre class="doc">Parses an identifier as a formal parameter. This means that
it will be translated as a symbol.</pre></div><div class="public" id="var-identifier"><h3>identifier</h3><div class="usage"></div><pre class="doc">Parses an identifier, checking for additional reserved words.
This parser expands the basic one in order to check for
reserved words entered by language extensions.</pre></div><div class="public" id="var-imp-decl"><h3>imp-decl</h3><div class="usage"></div><pre class="doc">Parses an import declaration

'import' identifier
 (  'as' identifier
  | 'only' '[' name ( ',' name )* ']'
  | 'hide' '[' name ( ',' name )* ']'
 )</pre></div><div class="public" id="var-in-sequence"><h3>in-sequence</h3><div class="usage"></div><pre class="doc">Parses expressions surrounded by in .. end.
Returns a vector of declarations, not a token map.

'in' expression ( ';' expression )* ( ';' )* 'end'</pre></div><div class="public" id="var-key-name"><h3>key-name</h3><div class="usage"></div><pre class="doc">Parses a Clojure keyword.
</pre></div><div class="public" id="var-lcat-op"><h3>lcat-op</h3><div class="usage"></div><pre class="doc">List concatenation operator.
</pre></div><div class="public" id="var-letex"><h3>letex</h3><div class="usage"></div><pre class="doc">Parses a let expression.

'let'
  (  name = expression
   | name parameter* = expression
  )*
'in' expression ( ';' expression )* ( ';' )* 'end'</pre></div><div class="public" id="var-letrec"><h3>letrec</h3><div class="usage"></div><pre class="doc">Parses a letrec expression. Bindings are functions that
can be recursive or mutually recursive.

'letrec'
  (  name = expression
   | name parameter* = expression
  )*
'in' expression ( ';' expression )* ( ';' )* 'end'</pre></div><div class="public" id="var-lexer"><h3>lexer</h3><div class="usage"><code>(lexer p)</code><code>(lexer tok rec)</code><code>(lexer tok rec &amp; args)</code></div><pre class="doc">Wraps a lexer parser to produce a token record with
the token code, value and position.</pre></div><div class="public" id="var-lisp-id"><h3>lisp-id</h3><div class="usage"></div><pre class="doc">Parses a lisp id with extra characters, as allowed by Clojure.
</pre></div><div class="public" id="var-lisp-name"><h3>lisp-name</h3><div class="usage"></div><pre class="doc">Parses a lisp name in backquotes to avoid interference with Eisen.
</pre></div><div class="public" id="var-list-lit"><h3>list-lit</h3><div class="usage"></div><pre class="doc">Parses a list literal: [expr,expr, ...].
</pre></div><div class="public" id="var-list-range"><h3>list-range</h3><div class="usage"></div><pre class="doc">Parses a list literal as a [low high] range, where these
bounds can be literal values or expressions.</pre></div><div class="public" id="var-local-binding"><h3>local-binding</h3><div class="usage"></div><pre class="doc">Parses a val or fun binding for let and similar constructs.

identifier parameter* '=' expression</pre></div><div class="public" id="var-macro%3F"><h3>macro?</h3><div class="usage"><code>(macro? s)</code></div><pre class="doc">Test if a string is the name of a macro; returns true or nil.
</pre></div><div class="public" id="var-map-lit"><h3>map-lit</h3><div class="usage"></div><pre class="doc">Parses a map literal: { key val, ... }.
</pre></div><div class="public" id="var-mod-decl"><h3>mod-decl</h3><div class="usage"></div><pre class="doc">Parses a module declaration.

import name[.name]*</pre></div><div class="public" id="var-mul-op"><h3>mul-op</h3><div class="usage"></div><pre class="doc">Multiplicative operators; a backslash denotes (quot);
% denotes (mod); * denotes multiplication; and / denotes
both division and integer ratio.</pre></div><div class="public" id="var-oct-lit*"><h3>oct-lit*</h3><div class="usage"></div><pre class="doc">Parses an octal literal, with no leading sign.
</pre></div><div class="public" id="var-or-op"><h3>or-op</h3><div class="usage"></div><pre class="doc">Operator || denotes logical or.
</pre></div><div class="public" id="var-pattern"><h3>pattern</h3><div class="usage"></div><pre class="doc">Either a literal value, a wildcard, or a name wildcard
in a pattern-matching expression.

Either one of:
* Keyword
* Character
* String
* Decimal number
* Octal number
* Hex number
* Floating-point number
* Boolean
* Nil
* List
* A name
* The wildcard _
* Vector pattern</pre></div><div class="public" id="var-pow-op"><h3>pow-op</h3><div class="usage"></div><pre class="doc">Power-of operator; implemented as a custom funcion exp.
</pre></div><div class="public" id="var-qualifier"><h3>qualifier</h3><div class="usage"></div><pre class="doc">Parses an import qualifier.

(  'as' identifier
 | 'only' '[' name ( ',' name )* ']'
 | 'hide' '[' name ( ',' name )* ']'
)</pre></div><div class="public" id="var-re-lit"><h3>re-lit</h3><div class="usage"></div><pre class="doc">Parses a regular-expression literal.
</pre></div><div class="public" id="var-rel-op"><h3>rel-op</h3><div class="usage"></div><pre class="doc">Relational operators: &gt;=, &lt;=, &gt;, &lt;.
</pre></div><div class="public" id="var-seqex"><h3>seqex</h3><div class="usage"></div><pre class="doc">Parses sequenced expressions as a single function arguments.
It's an alternative to do ... end as argument in function
calls. Returns the last value.

'(' expression ( ';' expression )* ( ';' )* ')'</pre></div><div class="public" id="var-set-lit"><h3>set-lit</h3><div class="usage"></div><pre class="doc">Parses a set literal: #{ expr, expr, ... }.
</pre></div><div class="public" id="var-setqex"><h3>setqex</h3><div class="usage"></div><pre class="doc">Parses a setq statement.

'setq' host-name = expression</pre></div><div class="public" id="var-setvex"><h3>setvex</h3><div class="usage"></div><pre class="doc">Parses a setv statement.

'setv' host-name = eisen-name</pre></div><div class="public" id="var-shft-op"><h3>shft-op</h3><div class="usage"></div><pre class="doc">Bitwise shift operators; &lt;&lt; denotes (bit-shift-left);
&gt;&gt; denotes (bit-shift-right).</pre></div><div class="public" id="var-sym-arg"><h3>sym-arg</h3><div class="usage"></div><pre class="doc">Parses a symbol as an argument for macros. It will be translated
as a Clojure symbol; need not have been declared.</pre></div><div class="public" id="var-uni-op"><h3>uni-op</h3><div class="usage"></div><pre class="doc">Unary operators not, bitwise not, plus, minus.
</pre></div><div class="public" id="var-val-call"><h3>val-call</h3><div class="usage"></div><pre class="doc">Parses a reference to a value, calling a function, or calling a macro.
</pre></div><div class="public" id="var-val-decl"><h3>val-decl</h3><div class="usage"></div><pre class="doc">Parses a declaration for a named value.

'val' identifier '=' expression</pre></div><div class="public" id="var-vec-range"><h3>vec-range</h3><div class="usage"></div><pre class="doc">Parses a vector literal as a #[low high] range, where these
bounds can be literal values or expressions.</pre></div><div class="public" id="var-vector-lit"><h3>vector-lit</h3><div class="usage"></div><pre class="doc">Parses a vector literal: #[expr, expr, ...].
</pre></div><div class="public" id="var-vector-pattern"><h3>vector-pattern</h3><div class="usage"></div><pre class="doc">Parses a vector pattern as a target for matching.
</pre></div><div class="public" id="var-wildcard"><h3>wildcard</h3><div class="usage"></div><pre class="doc">Parses the wildcard character.
</pre></div></div></body></html>